[
  {
    "projectId": "5dc76464-2e2d-497e-9e07-ede1212ae32e",
    "testId": "f46783be-3f9f-425d-be28-5d529d9ecfdb",
    "userId": "04e834d8-b061-7021-f4ea-643aac5c3694",
    "title": "TC001-Username-based login success",
    "description": "Verify users can successfully authenticate using valid username and password credentials.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to login page by finding the login link or button\n        frame = context.pages[-1]\n        # Click on the MMW Hubix link or logo to check if it leads to login or main dashboard\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        await page.mouse.wheel(0, 300)\n        \n\n        # -> Click the Login button to navigate to the login page\n        frame = context.pages[-1]\n        # Click the Login button to go to the login page\n        elem = frame.locator('xpath=html/body/div[2]/header/div/nav/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Enter valid username 'admin' in the username field\n        frame = context.pages[-1]\n        # Enter valid username 'admin' in the username field\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Enter correct password 'mmw2025' in the password field\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('mmw2025')\n        \n\n        frame = context.pages[-1]\n        # Click the Login button to submit credentials\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to navigate to the Admin section (index 6) to check if user is authenticated or if login is required again\n        frame = context.pages[-1]\n        # Click the Admin link to check if user is authenticated or redirected to login\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/nav/div[5]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Admin Dashboard').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Manage all aspects of the MMW Hubix portal').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04e834d8-b061-7021-f4ea-643aac5c3694/1763387562047686//tmp/test_task/result.webm",
    "created": "2025-11-17T13:48:08.140Z",
    "modified": "2025-11-17T13:52:42.224Z"
  },
  {
    "projectId": "5dc76464-2e2d-497e-9e07-ede1212ae32e",
    "testId": "03868e2a-cddf-4de0-a56b-cbbadfacc100",
    "userId": "04e834d8-b061-7021-f4ea-643aac5c3694",
    "title": "TC002-Login failure with incorrect credentials",
    "description": "Verify login fails with invalid username or password and appropriate error message is displayed.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to login page by finding and clicking the login link or button.\n        frame = context.pages[-1]\n        # Click on the MMW Hubix link or logo to check if it leads to login or main page with login option\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try clicking the 'Login' button (index 6) on the top right to access the login page.\n        frame = context.pages[-1]\n        # Click the 'Login' button on the top right to navigate to the login page\n        elem = frame.locator('xpath=html/body/div[2]/header/div/nav/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Enter invalid username and password, then click login button.\n        frame = context.pages[-1]\n        # Enter invalid username 'admin'\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Enter invalid password 'mmw2025'\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('mmw2025')\n        \n\n        frame = context.pages[-1]\n        # Click the login button to submit invalid credentials\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Login Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Login did not fail as expected with invalid username or password, or the appropriate error message was not displayed.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login attempt with invalid credentials was blocked by rate limiting, showing error: 'Too many requests, please try again later.' This prevents verifying the expected invalid login error message. Test stopped due to this limitation.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 401 (Unauthorized) (at http://localhost:3000/api/admin/settings:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/admin/settings:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/resources:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/categories:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/auth/providers:0:0)\n[ERROR] [next-auth][error][CLIENT_FETCH_ERROR] \nhttps://next-auth.js.org/errors#client_fetch_error undefined {error: Object, url: /api/auth/providers, message: undefined} (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/auth/_log:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/auth/error:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04e834d8-b061-7021-f4ea-643aac5c3694/1763387497379567//tmp/test_task/result.webm",
    "created": "2025-11-17T13:48:08.145Z",
    "modified": "2025-11-17T13:51:37.529Z"
  },
  {
    "projectId": "5dc76464-2e2d-497e-9e07-ede1212ae32e",
    "testId": "5d2ce4dc-c843-49b2-999d-a2b2e0c1c1d2",
    "userId": "04e834d8-b061-7021-f4ea-643aac5c3694",
    "title": "TC003-Google OAuth login success",
    "description": "Verify users can successfully authenticate using Google OAuth login method.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to the login page\n        frame = context.pages[-1]\n        # Click on the main site logo or link to find login or navigate to login page\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try clicking the 'Login' button to access the login page\n        frame = context.pages[-1]\n        # Click on the 'Login' button to navigate to the login page\n        elem = frame.locator('xpath=html/body/div[2]/header/div/nav/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on Google OAuth login button\n        frame = context.pages[-1]\n        # Click on the Google OAuth login button to start authentication flow\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/main/div/section/div[3]/div[5]/div[2]/div[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Complete Google OAuth authentication flow with valid Google account\n        await page.goto('https://accounts.google.com/signin', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input Google account email and proceed\n        frame = context.pages[-1]\n        # Input Google account email or phone\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/c-wiz/main/div[2]/div/div/div/form/span/section/div/div/div/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Click Next button to proceed with Google sign-in\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/c-wiz/main/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Authentication Failed: Invalid Credentials').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: User authentication via Google OAuth did not succeed as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Google OAuth login could not be completed because the Google sign-in page rejected the login attempt with a security error. This prevents verifying successful authentication and redirection to the dashboard. Please investigate browser compatibility or OAuth configuration issues.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 401 (Unauthorized) (at http://localhost:3000/api/admin/settings:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/admin/settings:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/categories:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/resources:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04e834d8-b061-7021-f4ea-643aac5c3694/1763387560792617//tmp/test_task/result.webm",
    "created": "2025-11-17T13:48:08.150Z",
    "modified": "2025-11-17T13:52:40.937Z"
  },
  {
    "projectId": "5dc76464-2e2d-497e-9e07-ede1212ae32e",
    "testId": "83503128-b09e-43b4-b85c-40b36b0b04a8",
    "userId": "04e834d8-b061-7021-f4ea-643aac5c3694",
    "title": "TC004-Role-based access control enforcement for ADMIN",
    "description": "Verify users with ADMIN role can access and perform actions on admin console pages and APIs.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Find and click login or admin console access to login as ADMIN user.\n        await page.mouse.wheel(0, 300)\n        \n\n        # -> Click the Login button to start login as ADMIN user.\n        frame = context.pages[-1]\n        # Click Login button to open login form\n        elem = frame.locator('xpath=html/body/div[2]/header/div/nav/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input ADMIN username and password and submit login form.\n        frame = context.pages[-1]\n        # Input ADMIN username\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input ADMIN password\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('mmw2025')\n        \n\n        frame = context.pages[-1]\n        # Click Login button to submit credentials\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'Admin' navigation link to access the admin console user management page.\n        frame = context.pages[-1]\n        # Click on 'Admin' navigation link to access admin console user management page\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/nav/div[5]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Users' button to access user management page for CRUD operations.\n        frame = context.pages[-1]\n        # Click on 'Users' button to access user management page\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/div/aside/nav/div/a[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Add User' button to start creating a new user.\n        frame = context.pages[-1]\n        # Click 'Add User' button to open user creation form\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/div/main/div/div/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the user creation form with valid data and submit to create a new user.\n        frame = context.pages[-1]\n        # Input username for new user\n        elem = frame.locator('xpath=html/body/div[4]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser1')\n        \n\n        frame = context.pages[-1]\n        # Input name for new user\n        elem = frame.locator('xpath=html/body/div[4]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n\n        frame = context.pages[-1]\n        # Input email for new user\n        elem = frame.locator('xpath=html/body/div[4]/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser1@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input password for new user\n        elem = frame.locator('xpath=html/body/div[4]/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Click role dropdown to select Admin role\n        elem = frame.locator('xpath=html/body/div[4]/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Admin' role option to select it, then click 'Create User' button to submit the form.\n        frame = context.pages[-1]\n        # Select 'Admin' role from dropdown options\n        elem = frame.locator('xpath=html/body/div[5]/div/div/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Create User' button to submit the form and create the new user.\n        frame = context.pages[-1]\n        # Click 'Create User' button to submit the new user form\n        elem = frame.locator('xpath=html/body/div[4]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the 'Department' field and resubmit the form to create the new user.\n        frame = context.pages[-1]\n        # Input department for new user\n        elem = frame.locator('xpath=html/body/div[4]/form/div[6]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('IT Support')\n        \n\n        frame = context.pages[-1]\n        # Click 'Create User' button to submit the form after filling department\n        elem = frame.locator('xpath=html/body/div[4]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the edit button for 'testuser1' to update user details.\n        frame = context.pages[-1]\n        # Click edit button for user 'testuser1' to update details\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/div/main/div/div/div/div[2]/div[2]/div/table/tbody/tr/td[7]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input a new password and click 'Save Changes' to update the user.\n        frame = context.pages[-1]\n        # Input new password for user update\n        elem = frame.locator('xpath=html/body/div[4]/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('newpassword123')\n        \n\n        frame = context.pages[-1]\n        # Click 'Save Changes' button to submit updated user details\n        elem = frame.locator('xpath=html/body/div[4]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the delete button for 'testuser1' to delete the user.\n        frame = context.pages[-1]\n        # Click delete button for user 'testuser1' to delete the user\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/div/main/div/div/div/div[2]/div[2]/div/table/tbody/tr/td[7]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Access Denied: You do not have ADMIN privileges').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test plan execution failed because ADMIN user could not perform CRUD operations on the admin console user management page as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Tested ADMIN user login, navigation to admin console, and CRUD operations on users. User creation and update succeeded, but user deletion failed due to non-functional delete button. Reported the issue and stopped further testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 401 (Unauthorized) (at http://localhost:3000/api/admin/settings:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/categories:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/resources:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/admin/users:0:0)\n[ERROR] [ERROR] Error fetching users: Error: Failed to fetch users\n    at fetchUsers (http://localhost:3000/_next/static/chunks/components_37df6971._.js:2026:31) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/admin/users:0:0)\n[ERROR] [ERROR] Error fetching users: Error: Failed to fetch users\n    at fetchUsers (http://localhost:3000/_next/static/chunks/components_37df6971._.js:2026:31) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04e834d8-b061-7021-f4ea-643aac5c3694/1763387975387735//tmp/test_task/result.webm",
    "created": "2025-11-17T13:48:08.156Z",
    "modified": "2025-11-17T13:59:35.515Z"
  },
  {
    "projectId": "5dc76464-2e2d-497e-9e07-ede1212ae32e",
    "testId": "6d3bb18c-a5ff-48ca-a3f4-76d2bdcfcd37",
    "userId": "04e834d8-b061-7021-f4ea-643aac5c3694",
    "title": "TC005-Role-based access control denial for HELPER and STUDENT on admin pages",
    "description": "Verify users with HELPER or STUDENT roles cannot access admin-only pages or APIs.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the login or user menu to start login as HELPER user.\n        frame = context.pages[-1]\n        # Click on the MMW Hubix link or logo to find login or user menu\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Login' button to open the login form and proceed with HELPER user login.\n        frame = context.pages[-1]\n        # Click the 'Login' button to open the login form\n        elem = frame.locator('xpath=html/body/div[2]/header/div/nav/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input HELPER user credentials and click login button.\n        frame = context.pages[-1]\n        # Input username for HELPER user\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('helper')\n        \n\n        frame = context.pages[-1]\n        # Input password for HELPER user\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('mmw2025')\n        \n\n        frame = context.pages[-1]\n        # Click login button to submit HELPER user credentials\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Admin Access Granted').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Users with HELPER or STUDENT roles should not access admin-only pages or APIs, but access was incorrectly granted.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing cannot proceed because login attempts for HELPER and STUDENT roles are blocked by server-side rate limiting ('Too many requests' error). This prevents verifying that these roles cannot access admin-only pages or APIs. Please resolve the rate limiting issue to enable further testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 401 (Unauthorized) (at http://localhost:3000/api/admin/settings:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/resources:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/categories:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/auth/providers:0:0)\n[ERROR] [next-auth][error][CLIENT_FETCH_ERROR] \nhttps://next-auth.js.org/errors#client_fetch_error undefined {error: Object, url: /api/auth/providers, message: undefined} (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/auth/_log:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/auth/error:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04e834d8-b061-7021-f4ea-643aac5c3694/1763387520260898//tmp/test_task/result.webm",
    "created": "2025-11-17T13:48:08.161Z",
    "modified": "2025-11-17T13:52:00.429Z"
  },
  {
    "projectId": "5dc76464-2e2d-497e-9e07-ede1212ae32e",
    "testId": "9acb0f7c-f74b-4b4b-a95e-c2561089a515",
    "userId": "04e834d8-b061-7021-f4ea-643aac5c3694",
    "title": "TC006-Public Resource Hub real-time search functionality",
    "description": "Verify that resource hub search updates results dynamically as the user types and filters results appropriately.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Enter partial keywords into the search input to test dynamic update of results.\n        frame = context.pages[-1]\n        # Enter partial keywords 'test' into the search input to check dynamic filtering of results\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/main/div/section/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('test')\n        \n\n        # -> Clear the search input to verify the full resource list is displayed without filters.\n        frame = context.pages[-1]\n        # Clear the search input to reset filters and show full resource list\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/main/div/section/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        # -> Test filtering by category buttons to verify results update accordingly.\n        frame = context.pages[-1]\n        # Click on 'Software' category filter button to filter resources by Software category\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/main/div/section/div[2]/div/div/div/button[6]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Chrome Web Store').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Windows Update Center').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Browse and install Chrome extensions and apps').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Microsoft Windows update and troubleshooting center').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Quick access to all essential school resources, tools, and information in one centralized location.').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04e834d8-b061-7021-f4ea-643aac5c3694/176338747241913//tmp/test_task/result.webm",
    "created": "2025-11-17T13:48:08.167Z",
    "modified": "2025-11-17T13:51:12.631Z"
  },
  {
    "projectId": "5dc76464-2e2d-497e-9e07-ede1212ae32e",
    "testId": "fe8bab17-065d-4e42-b090-238be0e0c82f",
    "userId": "04e834d8-b061-7021-f4ea-643aac5c3694",
    "title": "TC007-Club announcement RSVP and attendance tracking flow",
    "description": "Verify students can RSVP to club announcements, attendance progress bars update accordingly, and cannot RSVP multiple times.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click login or navigate to login page to start login as STUDENT user.\n        frame = context.pages[-1]\n        # Click on MMW Hubix logo or link to check if it leads to login or main menu.\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the Login button at index 6 to try to access the login page or form.\n        frame = context.pages[-1]\n        # Click the Login button to navigate to the login page or reveal login form.\n        elem = frame.locator('xpath=html/body/div[2]/header/div/nav/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input username and password and click login button to authenticate as STUDENT user.\n        frame = context.pages[-1]\n        # Input username 'admin' in the username field.\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input password 'mmw2025' in the password field.\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('mmw2025')\n        \n\n        frame = context.pages[-1]\n        # Click the Login button to submit credentials and login.\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=RSVP Success! You are now registered.').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The RSVP process did not complete successfully, or the attendance progress bar did not update as expected. Duplicate RSVPs might not be properly prevented.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to server rate limiting on login attempts. Unable to authenticate as STUDENT user, so RSVP functionality cannot be tested. Please resolve the rate limiting issue to proceed.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 401 (Unauthorized) (at http://localhost:3000/api/admin/settings:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/admin/settings:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/resources:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/categories:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/auth/providers:0:0)\n[ERROR] [next-auth][error][CLIENT_FETCH_ERROR] \nhttps://next-auth.js.org/errors#client_fetch_error undefined {error: Object, url: /api/auth/providers, message: undefined} (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/auth/_log:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/auth/error:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04e834d8-b061-7021-f4ea-643aac5c3694/1763387527745634//tmp/test_task/result.webm",
    "created": "2025-11-17T13:48:08.172Z",
    "modified": "2025-11-17T13:52:07.876Z"
  },
  {
    "projectId": "5dc76464-2e2d-497e-9e07-ede1212ae32e",
    "testId": "f634bca8-d34f-496c-8e9e-093946240491",
    "userId": "04e834d8-b061-7021-f4ea-643aac5c3694",
    "title": "TC008-AI Assistant chat rate limit handling",
    "description": "Verify the AI chat widget enforces rate limits and provides user-friendly notifications when limit is reached.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the AI assistant widget to open the chat interface.\n        frame = context.pages[-1]\n        # Click on the 'Open AI Assistant' button to open the chat widget.\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/main/div/section/div[2]/div/div/div/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Open AI Assistant' button (index 17) to open the AI chat widget chat interface.\n        frame = context.pages[-1]\n        # Click the 'Open AI Assistant' button to open the AI chat widget chat interface.\n        elem = frame.locator('xpath=html/body/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Send rapid consecutive chat requests exceeding the rate limit.\n        frame = context.pages[-1]\n        # Input first test message to AI chat widget.\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test message 1')\n        \n\n        # -> Send the first test message by clicking the send button, then rapidly send additional messages to exceed the rate limit.\n        frame = context.pages[-1]\n        # Send first test message by clicking the send button.\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/form/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Rate limit exceeded: please wait before sending more messages').first).to_be_visible(timeout=5000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The AI chat widget did not show the expected rate limit error message when the limit was exceeded as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The AI assistant chat widget is not responding due to connection errors, preventing the completion of rate limit testing. Please fix the connection issue to enable further testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 401 (Unauthorized) (at http://localhost:3000/api/admin/settings:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/admin/settings:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/resources:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/categories:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/chat:0:0)\n[ERROR] [ERROR] Chat error: Error: Failed to get response\n    at sendMessage (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:4339:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04e834d8-b061-7021-f4ea-643aac5c3694/1763387583859323//tmp/test_task/result.webm",
    "created": "2025-11-17T13:48:08.177Z",
    "modified": "2025-11-17T13:53:04.043Z"
  },
  {
    "projectId": "5dc76464-2e2d-497e-9e07-ede1212ae32e",
    "testId": "6161064c-03c1-4169-9e2d-4976b936c0ae",
    "userId": "04e834d8-b061-7021-f4ea-643aac5c3694",
    "title": "TC009-IT Prefect dashboard profile update and password change",
    "description": "Verify IT Prefect users can update their profiles and change passwords with validation and session persistence.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on login or find login form to input credentials\n        frame = context.pages[-1]\n        # Click on MMW Hubix logo or link to check if it leads to login or main dashboard\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the login button to open login form\n        frame = context.pages[-1]\n        # Click the Login button to open login form\n        elem = frame.locator('xpath=html/body/div[2]/header/div/nav/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input username and password, then click login button\n        frame = context.pages[-1]\n        # Input username 'admin'\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input password 'mmw2025'\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('mmw2025')\n        \n\n        frame = context.pages[-1]\n        # Click login button to submit credentials\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Locate and click the correct login button or link to authenticate as IT Prefect user 'admin'\n        frame = context.pages[-1]\n        # Click on 'IT Perfect Hub' link to navigate to IT Prefect user login or dashboard page\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/nav/div[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Profile update successful and password changed').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: IT Prefect user profile update and password change did not complete successfully as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to inability to login as IT Prefect user 'admin'. The system only allows guest access with no option to authenticate. Cannot proceed with profile update and password change verification.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 401 (Unauthorized) (at http://localhost:3000/api/admin/settings:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/admin/settings:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/categories:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/resources:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04e834d8-b061-7021-f4ea-643aac5c3694/1763387678722969//tmp/test_task/result.webm",
    "created": "2025-11-17T13:48:08.184Z",
    "modified": "2025-11-17T13:54:38.880Z"
  },
  {
    "projectId": "5dc76464-2e2d-497e-9e07-ede1212ae32e",
    "testId": "71f955e8-95d8-4061-9fac-f2ade37ce1ed",
    "userId": "04e834d8-b061-7021-f4ea-643aac5c3694",
    "title": "TC010-Admin system-wide settings change with real-time application",
    "description": "Verify admin users can update system settings and changes reflect immediately across the site and persist after export/import.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the login or admin access link to start login as ADMIN user.\n        frame = context.pages[-1]\n        # Click Open AI Assistant button to check if it leads to login or admin access\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/main/div/section/div[2]/div/div/div/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try clicking the 'Login' button at index 6 to access the admin login page.\n        frame = context.pages[-1]\n        # Click the 'Login' button to access admin login page\n        elem = frame.locator('xpath=html/body/div[2]/header/div/nav/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input admin username and password, then click login button to authenticate.\n        frame = context.pages[-1]\n        # Input admin username\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input admin password\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('mmw2025')\n        \n\n        frame = context.pages[-1]\n        # Click login button to authenticate as admin\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=System Settings Updated Successfully').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Admin users could not update system settings or changes did not reflect immediately across the site as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to rate limiting blocking admin login attempts. Cannot verify admin user capabilities without successful login. Issue reported for resolution.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 401 (Unauthorized) (at http://localhost:3000/api/admin/settings:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/admin/settings:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/resources:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/categories:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/auth/providers:0:0)\n[ERROR] [next-auth][error][CLIENT_FETCH_ERROR] \nhttps://next-auth.js.org/errors#client_fetch_error undefined {error: Object, url: /api/auth/providers, message: undefined} (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/auth/_log:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/auth/error:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04e834d8-b061-7021-f4ea-643aac5c3694/1763387500540761//tmp/test_task/result.webm",
    "created": "2025-11-17T13:48:08.190Z",
    "modified": "2025-11-17T13:51:40.688Z"
  },
  {
    "projectId": "5dc76464-2e2d-497e-9e07-ede1212ae32e",
    "testId": "63505dd5-2c7c-4315-a8e1-3be9f00c4393",
    "userId": "04e834d8-b061-7021-f4ea-643aac5c3694",
    "title": "TC011-Training Library categorized video view and tracking",
    "description": "Verify users can browse training library by categories, view videos, and views are tracked correctly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the login or user menu to start login process.\n        frame = context.pages[-1]\n        # Click on MMW Hubix logo or menu to check for login or user options\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'Login' button to start the login process.\n        frame = context.pages[-1]\n        # Click on the 'Login' button to open login form\n        elem = frame.locator('xpath=html/body/div[2]/header/div/nav/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input username and password, then click login button to authenticate.\n        frame = context.pages[-1]\n        # Input username 'admin'\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input password 'mmw2025'\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('mmw2025')\n        \n\n        frame = context.pages[-1]\n        # Click login button to submit credentials\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Training Video Playback Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Unable to verify video playback and view count increment as per the test plan to browse training library by categories, view videos, and track views correctly.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login attempts are blocked by rate limiting with the error 'Too many requests, please try again later.' This prevents authentication and further testing of browsing the training library, video playback, and view tracking. Please resolve the rate limiting issue to enable testing. Task stopped due to inability to login.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 401 (Unauthorized) (at http://localhost:3000/api/admin/settings:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/admin/settings:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/categories:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/resources:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/auth/providers:0:0)\n[ERROR] [next-auth][error][CLIENT_FETCH_ERROR] \nhttps://next-auth.js.org/errors#client_fetch_error undefined {error: Object, url: /api/auth/providers, message: undefined} (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/auth/_log:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/auth/error:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04e834d8-b061-7021-f4ea-643aac5c3694/1763387507946463//tmp/test_task/result.webm",
    "created": "2025-11-17T13:48:08.197Z",
    "modified": "2025-11-17T13:51:48.075Z"
  },
  {
    "projectId": "5dc76464-2e2d-497e-9e07-ede1212ae32e",
    "testId": "0de4531d-4fb5-4e04-8466-2f6c2346b229",
    "userId": "04e834d8-b061-7021-f4ea-643aac5c3694",
    "title": "TC012-Event calendar syncing from activities",
    "description": "Verify events created or updated from the activities module sync properly to both internal and public calendars.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the login or user menu to start login as ADMIN user.\n        frame = context.pages[-1]\n        # Click Open AI Assistant button to check if login option is there\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/main/div/section/div[2]/div/div/div/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try clicking the 'Login' button at index 6 to access login page.\n        frame = context.pages[-1]\n        # Click the 'Login' button to access login page\n        elem = frame.locator('xpath=html/body/div[2]/header/div/nav/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input username and password for ADMIN user and click login.\n        frame = context.pages[-1]\n        # Input username admin\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input password mmw2025\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('mmw2025')\n        \n\n        frame = context.pages[-1]\n        # Click login button\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Event Sync Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Events created or updated from the activities module did not sync properly to internal and public calendars as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Task cannot proceed because login as ADMIN user is blocked by rate limiting error. Please resolve the rate limiting issue to continue testing event sync to calendars.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 401 (Unauthorized) (at http://localhost:3000/api/admin/settings:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/admin/settings:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/categories:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/resources:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/auth/providers:0:0)\n[ERROR] [next-auth][error][CLIENT_FETCH_ERROR] \nhttps://next-auth.js.org/errors#client_fetch_error undefined {error: Object, url: /api/auth/providers, message: undefined} (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/auth/_log:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/auth/error:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04e834d8-b061-7021-f4ea-643aac5c3694/1763387507425553//tmp/test_task/result.webm",
    "created": "2025-11-17T13:48:08.204Z",
    "modified": "2025-11-17T13:51:47.568Z"
  },
  {
    "projectId": "5dc76464-2e2d-497e-9e07-ede1212ae32e",
    "testId": "34b887e2-2355-416c-b70c-d5f1c0df88ad",
    "userId": "04e834d8-b061-7021-f4ea-643aac5c3694",
    "title": "TC013-Media upload and video playback end-to-end",
    "description": "Verify that media uploads, including videos, are accepted, stored, and playable through the portal UI.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click login or open login form to input admin credentials.\n        frame = context.pages[-1]\n        # Click Open AI Assistant button to check if login is accessible here or find login link\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/main/div/section/div[2]/div/div/div/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to find and click the 'Login' button at index 6 to access the login form.\n        frame = context.pages[-1]\n        # Click the 'Login' button to open the login form for admin credentials input\n        elem = frame.locator('xpath=html/body/div[2]/header/div/nav/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input username and password, then click login button to authenticate as admin.\n        frame = context.pages[-1]\n        # Input username 'admin'\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input password 'mmw2025'\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('mmw2025')\n        \n\n        frame = context.pages[-1]\n        # Click login button to submit credentials\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Video Upload Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Media upload test did not complete successfully as expected. The uploaded video was not accepted, stored, or playable through the portal UI.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to rate limiting on login attempts. Unable to proceed with media upload verification without admin access. Please resolve the rate limiting issue to continue testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 401 (Unauthorized) (at http://localhost:3000/api/admin/settings:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/resources:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/categories:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/auth/providers:0:0)\n[ERROR] [next-auth][error][CLIENT_FETCH_ERROR] \nhttps://next-auth.js.org/errors#client_fetch_error undefined {error: Object, url: /api/auth/providers, message: undefined} (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/auth/_log:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/auth/error:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04e834d8-b061-7021-f4ea-643aac5c3694/1763387512489611//tmp/test_task/result.webm",
    "created": "2025-11-17T13:48:08.210Z",
    "modified": "2025-11-17T13:51:52.623Z"
  },
  {
    "projectId": "5dc76464-2e2d-497e-9e07-ede1212ae32e",
    "testId": "a8a23a97-f219-400b-8ff9-d0d1fae3fd47",
    "userId": "04e834d8-b061-7021-f4ea-643aac5c3694",
    "title": "TC014-Security - Rate limiting enforcement on public APIs",
    "description": "Verify that rate limiting is effectively applied to public APIs such as AI chat and announcements API, blocking excessive requests.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Send rapid, repeated requests exceeding standard threshold to AI chat API to verify rate limiting.\n        await page.goto('http://localhost:3000/api/ai-chat', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Send repeated requests exceeding threshold to announcements public API to verify rate limiting.\n        await page.goto('http://localhost:3000/api/announcements', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Too many requests, please try again later.').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04e834d8-b061-7021-f4ea-643aac5c3694/1763387342902697//tmp/test_task/result.webm",
    "created": "2025-11-17T13:48:08.218Z",
    "modified": "2025-11-17T13:49:03.067Z"
  },
  {
    "projectId": "5dc76464-2e2d-497e-9e07-ede1212ae32e",
    "testId": "67b6e204-5d2d-44c4-8fb8-4b698fbec7fc",
    "userId": "04e834d8-b061-7021-f4ea-643aac5c3694",
    "title": "TC015-Input sanitization prevents malicious input",
    "description": "Verify all user inputs in forms and APIs are sanitized to prevent injection, XSS, or other common attack vectors.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Locate a login or user input form to test injection and XSS patterns.\n        await page.mouse.wheel(0, 300)\n        \n\n        # -> Click the 'Login' button to open the login form and test input sanitization.\n        frame = context.pages[-1]\n        # Click the Login button to open the login form\n        elem = frame.locator('xpath=html/body/div[2]/header/div/nav/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input script and SQL injection patterns into username and password fields and submit the form to verify sanitization.\n        frame = context.pages[-1]\n        # Input XSS script pattern into username field\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"<script>alert('XSS')</script>\")\n        \n\n        frame = context.pages[-1]\n        # Input SQL injection pattern into password field\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"' OR '1'='1\")\n        \n\n        # -> Test the IT Support Form for similar injection and XSS vulnerabilities by locating and submitting it with malicious inputs.\n        frame = context.pages[-1]\n        # Close the login form dialog\n        elem = frame.locator('xpath=html/body/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the IT Support Form link or button to open the form and test input sanitization.\n        frame = context.pages[-1]\n        # Click IT Support Form link or button to open the form\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/main/div/section/div[3]/div[4]/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Injection Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Input sanitization did not prevent injection or XSS vulnerabilities as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing completed for the login form with injection patterns; no sanitization or rejection feedback was observed. The IT Support Form could not be tested because its link redirects to an unrelated external support page, preventing further input sanitization testing. Please review and fix the IT Support Form link to enable comprehensive security testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 401 (Unauthorized) (at http://localhost:3000/api/admin/settings:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/categories:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/resources:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04e834d8-b061-7021-f4ea-643aac5c3694/1763387586136603//tmp/test_task/result.webm",
    "created": "2025-11-17T13:48:08.236Z",
    "modified": "2025-11-17T13:53:06.373Z"
  },
  {
    "projectId": "5dc76464-2e2d-497e-9e07-ede1212ae32e",
    "testId": "7297dda2-5053-4297-bb38-40ed03ac7368",
    "userId": "04e834d8-b061-7021-f4ea-643aac5c3694",
    "title": "TC016-Error logging captures client, server, and edge errors",
    "description": "Verify that all types of errors occurring client-side and server-side are captured and logged with sufficient detail.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Trigger client-side error by invalid operation on UI (e.g. accessing undefined component)\n        frame = context.pages[-1]\n        # Click Open AI Assistant to try triggering client-side error by invalid operation\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/main/div/section/div[2]/div/div/div/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Trigger client-side error by invalid operation on UI (e.g. accessing undefined component)\n        frame = context.pages[-1]\n        # Click Open AI Assistant to try triggering client-side error by invalid operation\n        elem = frame.locator('xpath=html/body/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Trigger client-side error by invalid operation on UI (e.g. accessing undefined component)\n        frame = context.pages[-1]\n        # Input text to AI Assistant chat to try triggering client-side error by invalid operation\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('trigger error')\n        \n\n        # -> Trigger a more explicit client-side error by interacting with a known undefined or broken UI component or script to ensure error capture.\n        frame = context.pages[-1]\n        # Click Close chat to close AI Assistant and try other UI elements for client-side error triggering\n        elem = frame.locator('xpath=html/body/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        await page.mouse.wheel(0, 400)\n        \n\n        # -> Attempt to trigger client-side error by interacting with a known undefined or broken UI component or script.\n        frame = context.pages[-1]\n        # Click Password Manager Guide resource to try triggering client-side error if any\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/main/div/section/div[3]/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Trigger server-side API error by sending malformed request.\n        await page.goto('http://localhost:3000/api/test-malformed-request', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Attempt to trigger edge error via middleware by unauthorized access attempt.\n        await page.goto('http://localhost:3000/protected-resource', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Navigate to centralized logging or error monitoring page to verify error logs contain sufficient detail.\n        frame = context.pages[-1]\n        # Click Login button to access user context for logging verification\n        elem = frame.locator('xpath=html/body/div[2]/header/div/nav/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input admin username and password and submit login form to access user context for logging verification.\n        frame = context.pages[-1]\n        # Input username 'admin'\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input password 'mmw2025'\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('mmw2025')\n        \n\n        frame = context.pages[-1]\n        # Click Login button to submit credentials\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to centralized logging or error monitoring page to verify error logs contain timestamps, stack traces, and user context for all triggered errors.\n        frame = context.pages[-1]\n        # Click Admin link to access admin dashboard or logging page\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/nav/div[5]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to the 'History' section under IT Perfect Hub to check centralized logs for error details.\n        frame = context.pages[-1]\n        # Click History button to access centralized logging or error monitoring section\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/div/aside/nav/div[2]/a[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=All errors captured and logged successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Errors occurring client-side and server-side were not captured and logged with sufficient detail including timestamps, stack traces, and user context as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task to verify that all types of errors occurring client-side and server-side are captured and logged with sufficient detail is partially completed. Server-side and edge errors were triggered successfully, but no explicit client-side error was triggered or logged. Additionally, no error logs with timestamps, stack traces, or user context were found in the centralized logging/history section despite successful login as admin. This indicates a potential issue or gap in the error logging system. Further investigation or improvements may be needed to ensure comprehensive error capture and logging. Task not fully finished as requested.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 401 (Unauthorized) (at http://localhost:3000/api/admin/settings:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/admin/settings:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/categories:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/resources:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04e834d8-b061-7021-f4ea-643aac5c3694/1763387810636201//tmp/test_task/result.webm",
    "created": "2025-11-17T13:48:08.243Z",
    "modified": "2025-11-17T13:56:50.827Z"
  },
  {
    "projectId": "5dc76464-2e2d-497e-9e07-ede1212ae32e",
    "testId": "ee506038-1ba9-4311-9669-0c49b6510f46",
    "userId": "04e834d8-b061-7021-f4ea-643aac5c3694",
    "title": "TC017-Responsive design across desktop, tablet, and mobile",
    "description": "Verify the portal UI layouts and components render properly and maintain usability on desktop, tablet, and mobile screen sizes.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Resize viewport to mobile dimensions and verify navigation menus are accessible and content is readable without horizontal scrolling.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Resize viewport to mobile dimensions and verify navigation menus are accessible and content is readable without horizontal scrolling.\n        await page.mouse.wheel(0, 300)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=MMW Hubix').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Resource Hub').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Articles').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=School Website').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Login').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Quick access to all essential school resources, tools, and information in one centralized location.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Google').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=All Categories').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=8').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Uncategorized').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=3').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Networking').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=1').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Security').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Hardware').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Software').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=2 resources').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Chrome Web Store').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Browse and install Chrome extensions and apps').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Windows Update Center').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Microsoft Windows update and troubleshooting center').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=PC Hardware Guide').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Intel support documentation for computer hardware').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Password Manager Guide').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Learn how to use Google Password Manager securely').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Network Troubleshooting Guide').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Comprehensive guide for diagnosing network problems').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=IT Support Form').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Submit IT support requests and technical issues').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=School Email').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Access your school Gmail account').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Google Classroom').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Online learning management system for assignments and grades').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=School Information Portal for C.C.C. Mong Man Wai College').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text= 2025 C.C.C. Mong Man Wai College. All rights reserved.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=The first version was built by the IT Perfect team in 2024-2025.').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04e834d8-b061-7021-f4ea-643aac5c3694/1763387685894251//tmp/test_task/result.webm",
    "created": "2025-11-17T13:48:08.250Z",
    "modified": "2025-11-17T13:54:46.077Z"
  },
  {
    "projectId": "5dc76464-2e2d-497e-9e07-ede1212ae32e",
    "testId": "f7d27fdd-3ebd-4ed3-834c-6d289c640d4b",
    "userId": "04e834d8-b061-7021-f4ea-643aac5c3694",
    "title": "TC018-UI animations and transitions performance",
    "description": "Verify UI animations and transitions execute smoothly without jank and provide appropriate user feedback.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the 'All Categories' button to test dropdown animation and user feedback.\n        frame = context.pages[-1]\n        # Click on the 'All Categories' button to trigger dropdown animation and check for smoothness and visual feedback.\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div/main/div/section/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Animation Completed Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: UI animations and transitions did not execute smoothly or provide appropriate user feedback as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Reported a critical UI bug where clicking 'All Categories' resets resource counts and shows no resources. Stopping further UI animation and transition testing until this is fixed.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/admin/settings:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/settings:0:0)\n[ERROR] [ERROR] Failed to load settings: Error: Public settings endpoint failed\n    at loadSettings (http://localhost:3000/_next/static/chunks/_316bf6f2._.js:2617:23) (at http://localhost:3000/_next/static/chunks/node_modules_next_dist_b0daae9a._.js:2359:31)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/categories:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 (Too Many Requests) (at http://localhost:3000/api/resources:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04e834d8-b061-7021-f4ea-643aac5c3694/176338745281089//tmp/test_task/result.webm",
    "created": "2025-11-17T13:48:08.256Z",
    "modified": "2025-11-17T13:50:52.959Z"
  }
]
